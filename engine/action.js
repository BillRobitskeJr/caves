/**
 * Entity action abstraction
 * @copyright   Bill Robitske, Jr. 2018
 * @author      Bill Robitske, Jr. <bill.robitske.jr@gmail.com>
 * @license     MIT
 */

// Symbols for semi-private members
const _actor = Symbol('actor');
const _verbs = Symbol('verbs');
const _start = Symbol('start');
const _complete = Symbol('complete');

/**
 * Entity action class
 */
export default class Action {

  /**
   * @callback  Action.PhaseHandler
   * @param     {Entity}              actor     - Entity performing this action
   * @param     {EngineCore.Command}  command   - Command being performed
   * @param     {EngineCore.Output}   output    - Game output
   * @param     {Object}              entities  - Current/effective entities
   * @returns   {Action.StateUpdates}           - Requested updates generated by this action phase
   */

  /**
   * @typedef   Action.Entities
   * @property  {Entity}      game        - Current/effective game entity
   * @property  {Entity}      player      - Current/effective player entity
   * @property  {Collection}  locations   - Current/effective location entities
   * @property  {Collection}  objects     - Current/effective object entities
   */

  /**
   * @typedef   Action.StateUpdates
   * @property  {boolean}                             abort     - The current action should be stopped after this update request
   * @property  {Object.<string, *>}                  game      - Requested updates to the game entity state
   * @property  {Object.<string, *>}                  player    - Requested updates to the player entity state
   * @property  {Object.<number, Object.<string, *>>} locations - Requested updates to location entity states
   * @property  {Object.<number, Object.<string, *>>} objects   - Requested updates to object entity states
   */

  /**
   * Create a new entity action
   * @param     {Entity}              actor             - Entity able to perform this action
   * @param     {Object}              config            - Configuration for this action
   * @param     {string[]}            config.verbs      - Verbs associated with this action
   * @param     {Action.PhaseHandler} [config.start]    - Function to call during this action's start phase
   * @param     {Action.PhaseHandler} [config.complete] - Function to call during this action's complete phase
   */
  constructor(actor, config = {}) {
    this[_actor] = actor || new Entity();
    this[_verbs] = Array.from(config.verbs || []);
    this[_start] = typeof config.start === 'function' ? config.start : (() => {});
    this[_complete] = typeof config.complete === 'function' ? config.complete : (() => {});
  }

  /**
   * @property  {string[]}  verbs           - Verbs associated with this action
   * @readonly
   */
  get verbs() { return Array.from(this[_verbs]); }

  /**
   * @property  {RegExp}    verbExpression  - Regular expression for matching this action's verbs
   * @readonly
   */
  get verbExpression() { return new RegExp(`(${this[_verbs].join('|')})`, 'i'); }

  perform(command, output, entities) {
    console.log(`Action#perform(command, output, entities):`, {
      self: this,
      command, output, entities
    });
    const _entities = {
      game: entities.game.clone(),
      player: entities.player.clone(),
      locations: entities.locations.clone(),
      objects: entities.objects.clone()
    };

    // Start action and capture state updates
    const startUpdates = this.start(command, output, _entities);
    console.log(`Action#perform~startUpdates:`, startUpdates);
    if (startUpdates.abort) return { abort: true };
    this.updateEntities(_entities, startUpdates);

    // Trigger "start" phase reactions
    const startReactionUpdates = this.triggerReactions(command, output, _entities, 'start');
    console.log(`Action#perform~startReactionUpdates:`, startReactionUpdates);
    this.updateEntities(_entities, startReactionUpdates);

    // Complete action and capture state updates
    const completeUpdates = this.complete(command, output, _entities);
    console.log(`Action#perform~completeUpdates:`, completeUpdates);
    if (completeUpdates.abort) return { abort: true };
    this.updateEntities(_entities, completeUpdates);

    // Trigger "complete" phase reactions
    const completeReactionUpdates = this.triggerReactions(command, output, _entities, 'complete');
    console.log(`Action#perform~completeReactionUpdates:`, completeReactionUpdates);
    this.updateEntities(_entities, completeReactionUpdates);

    // Combine state updates
    const updates = this.mergeUpdates(startUpdates, startReactionUpdates, completeUpdates, completeReactionUpdates);
    console.log(`Action#perform~updates:`, updates);

    return updates;
  }

  /**
   * Start performing this action
   * @param     {EngineCore.Command}  command   - Command being performed
   * @param     {EngineCore.Output}   output    - Game output
   * @param     {Action.Entities}     entities  - Current/effective entities
   * @returns   {Action.StateUpdates}           - Requested updates to entity states
   */
  start(command, output, entities) {
    return this[_start](this[_actor], command, output, entities) || {};
  }

  /**
   * Complete this action
   * @param     {EngineCore.Command}  command   - Command being performed
   * @param     {EngineCore.Output}   output    - Game output
   * @param     {Action.Entities}     entities  - Current/effective entities
   * @returns   {Action.StateUpdates}           - Requested updates to entity states
   */
  complete(command, output, entities) {
    return this[_complete](this[_actor], command, output, entities) || {};
  }

  /**
   * Trigger reactions to this action
   * @param     {EngineCore.Command}  command   - Command being performed
   * @param     {EngineCore.Output}   output    - Game output
   * @param     {Action.Entities}     entities  - Current/effective entities
   * @param     {string}              phase     - Phase of triggering action
   * @returns   {Action.StateUpdates}           - Requested updates to entity states
   */
  triggerReactions(command, output, entities, phase) {
    const trigger = { type: 'action', verb: this[_verbs][0], phase };
    const reactions = [].concat(
      entities.game.getReactions(trigger),
      entities.player.getReactions(trigger),
      entities.locations.getReactions(trigger),
      entities.objects.getReactions(trigger)
    );
    const updates = reactions.map(reaction => reaction.action.perform(command, output, entities));
    return this.mergeUpdates(...updates);
  }

  /**
   * Merge state updates together
   * @param     {Action.StateUpdates[]} updates - Requested updates to entity states
   * @param     {Action.StateUpdates}           - Merged requested updates to entity states
   */
  mergeUpdates(...updates) {
    return updates.reduce((mergedUpdates, update) => {
      mergedUpdates.abort = !!mergedUpdates.abort || !!update.abort;
      mergedUpdates.game = Object.assign(mergedUpdates.game, update.game || {});
      mergedUpdates.player = Object.assign(mergedUpdates.player, update.player || {});
      Object.keys(update.locations || {}).forEach(id => {
        mergedUpdates.locations[id] = Object.assign(mergedUpdates.locations[id] || {}, update.locations[id]);
      });
      Object.keys(update.objects || {}).forEach(id => {
        mergedUpdates.objects[id] = Object.assign(mergedUpdates.objects[id] || {}, update.objects[id]);
      });
      return mergedUpdates;
    }, { game: {}, player: {}, locations: {}, objects: {} });
  }

  /**
   * Update entity statuses
   * @param     {Action.Entities}       entities  - Current/effective game entities
   * @param     {Action.StatusUpdates}  updates   - Requested updates to entities
   * @returns   {Action.Entities}                 - Updated game entities
   */
  updateEntities(entities, updates) {
    Object.keys(updates.game || {}).forEach(key => { entities.game.updateState(key, updates.game[key]); });
    Object.keys(updates.player || {}).forEach(key => { entities.player.updateState(key, updates.player[key]); });
    Object.keys(updates.locations || {}).forEach(id => {
      const location = entities.locations.getEntity(id);
      Object.keys(updates.locations[id]).forEach(key => { location.updateState(key, updates.locations[id][key]); });
    });
    Object.keys(updates.objects || {}).forEach(id => {
      const object = entities.objects.getEntity(id);
      Object.keys(updates.objects[id]).forEach(key => { object.updateState(key, updates.objects[id][key]); });
    });
    return entities;
  }

  /**
   * Create a copy of this action for another actor
   * @param     {Entity}  actor   - Entity able to perform the new copy of this action
   * @returns   {Action}          - New copy of this action
   */
  cloneForActor(actor) {
    return new Action(actor, {
      verbs: Array.from(this[_verbs]),
      start: this[_start],
      complete: this[_complete]
    });
  }
}
